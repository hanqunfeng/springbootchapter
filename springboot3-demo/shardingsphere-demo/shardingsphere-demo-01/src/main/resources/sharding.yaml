# 数据源配置: https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/yaml-config/data-source/
dataSources:
  ds_0: # 逻辑数据源名称
    dataSourceClassName: com.zaxxer.hikari.HikariDataSource
    driverClassName: com.mysql.cj.jdbc.Driver
    jdbcUrl: jdbc:mysql://127.0.0.1:3306/shardingdb0?useSSL=false&serverTimezone=UTC
    username: root
    password: newpwd

  ds_1:
    dataSourceClassName: com.zaxxer.hikari.HikariDataSource
    driverClassName: com.mysql.cj.jdbc.Driver
    jdbcUrl: jdbc:mysql://127.0.0.1:3306/shardingdb1?useSSL=false&serverTimezone=UTC
    username: root
    password: newpwd

# 分片规则配置: https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/sharding/
rules:
  - !SHARDING
    # 分片
    # 绑定表：同分片键 join 时走同路由，减少广播,多个逗号分隔，要求分片规则一致
    bindingTables:
      - t_order,t_order_item

    tables: # 手工分片规则配置
      course: # 逻辑表名称
        actualDataNodes: ds_${0..1}.course_${1..2} # 实际数据节点
        databaseStrategy: # 分库策略
          standard: # 用于单分片键的标准分片场景
            shardingColumn: user_id # 分片列名称
            shardingAlgorithmName: course_db_inline # 分片算法名称
        tableStrategy: # 分表策略
          standard:
            shardingColumn: cid
            shardingAlgorithmName: course_inline
        keyGenerateStrategy: # 分布式序列策略
          column: cid # 自增列名称
          keyGeneratorName: snowflake # 分布式序列算法名称
      t_order_complex: # 逻辑表名称
        actualDataNodes: ds_${0..1}.t_order_complex_${0..1} # 实际数据节点
        databaseStrategy: # 分库策略
          standard: # 用于单分片键的标准分片场景
            shardingColumn: user_id # 分片列名称
            shardingAlgorithmName: t_order_db_inline # 分片算法名称
        tableStrategy: # 分表策略
          complex: # 用于多分片键的复杂分片场景
            shardingColumns: user_id,order_id
            shardingAlgorithmName: t_order-complex-algorithm
        keyGenerateStrategy: # 分布式序列策略
          column: order_id # 自增列名称
          keyGeneratorName: snowflake # 分布式序列算法名称
      t_order_item_complex: # 逻辑表名称
        actualDataNodes: ds_${0..1}.t_order_item_complex_${0..1} # 实际数据节点
        databaseStrategy: # 分库策略
          standard: # 用于单分片键的标准分片场景
            shardingColumn: user_id # 分片列名称
            shardingAlgorithmName: t_order_db_inline # 分片算法名称
        tableStrategy: # 分表策略
          complex: # 用于多分片键的复杂分片场景
            shardingColumns: user_id,order_id  # 分片列名称,多个逗号分隔
#             shardingAlgorithmName: t_order_item-class-based-algorithm   # 基于自定义类的分片算法
            shardingAlgorithmName: t_order_item-class-based-algorithm_spi # 基于 SPI 的分片算法，效果同上，建议生产环境使用 SPI
        keyGenerateStrategy: # 分布式序列策略
          column: item_id # 自增列名称
          keyGeneratorName: snowflake # 分布式序列算法名称

      t_user:         # 普通表（不分库分表，绑定到 ds_1）,没有没人的数据源配置，每个都要显示声明
        actualDataNodes: ds_1.t_user # 实际数据节点
      t_address:      # 普通表（不分库分表，绑定到 ds_0）
        actualDataNodes: ds_0.t_address # 实际数据节点

    autoTables: # 自动分片规则配置
      t_order: # 逻辑表名称
        actualDataSources: ds_${0..1} # 数据源名称
        shardingStrategy: # 切分策略
          standard: # 用于单分片键的标准分片场景
            shardingColumn: user_id # 分片列名称
            shardingAlgorithmName: mod_2 # 自动分片算法名称
        keyGenerateStrategy: # 分布式序列策略
          column: order_id # 自增列名称
          keyGeneratorName: snowflake # 分布式序列算法名称
      t_order_item: # 逻辑表名称
        actualDataSources: ds_${0..1} # 数据源名称
        shardingStrategy: # 切分策略
          standard: # 用于单分片键的标准分片场景
            shardingColumn: user_id # 分片列名称
            shardingAlgorithmName: mod_2 # 自动分片算法名称
        keyGenerateStrategy: # 分布式序列策略
          column: item_id # 自增列名称
          keyGeneratorName: snowflake # 分布式序列算法名称

    shardingAlgorithms: # 分片算法 https://shardingsphere.apache.org/document/current/cn/dev-manual/sharding/
      course_inline: # 定义名称，在上面引用
        type: INLINE # 基于行表达式的分片算法，这里使用 MOD 会报错
        props: # 属性
          algorithm-expression: course_${cid % 2 + 1} # 表达式，这是因为表名称为 course_1, course_2
          allow-range-query-with-inline-sharding: true # 允许范围查询
      course_db_inline:
        type: INLINE
        props:
          algorithm-expression: ds_${user_id % 2} # 表示 ds_0, ds_1
      mod_2:
        type: MOD # 基于 MOD 的分片算法
        props:
          sharding-count: 2 # 分片数量，即 对 2 进行取余
      t_order_db_inline:
        type: INLINE
        props:
          algorithm-expression: ds_${user_id % 2}
      t_order-complex-algorithm:
        type: COMPLEX_INLINE # 基于行表达式的复合分片算法
        props:
          algorithm-expression: t_order_complex_${(user_id + order_id + 1) % 2}
      t_order_item-class-based-algorithm:
        type: CLASS_BASED # 基于自定义类的分片算法
        props:
          strategy: COMPLEX # 指定策略 STANDARD|COMPLEX|HINT ，告诉 ShardingSphere 分片算法类实现了什么策略
          algorithmClassName: com.hanqf.demo.algorithm.OrderItemComplexAlgorithm # 指定算法类
      t_order_item-class-based-algorithm_spi: # SPI
        type: T_ORDER_ITEM_COMPLEX # 基于自定义类的分片算法

    keyGenerators: # 主键生成器
      snowflake: # 定义名称，在上面引用
        type: SNOWFLAKE # 使用雪花算法

props:
  sql-show: true # 控制台打印改写后的 SQL，便于排错
  check-table-metadata-enabled: false # 是否检查表结构
