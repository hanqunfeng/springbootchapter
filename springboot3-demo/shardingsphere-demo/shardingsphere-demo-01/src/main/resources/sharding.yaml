# 数据源配置: https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/yaml-config/data-source/
dataSources:
  ds_0: # 逻辑数据源名称
    dataSourceClassName: com.zaxxer.hikari.HikariDataSource
    driverClassName: com.mysql.cj.jdbc.Driver
    jdbcUrl: jdbc:mysql://127.0.0.1:3306/shardingdb0?useSSL=false&serverTimezone=UTC&useUnicode=true&characterEncoding=UTF-8
    username: root
    password: newpwd

  ds_1:
    dataSourceClassName: com.zaxxer.hikari.HikariDataSource
    driverClassName: com.mysql.cj.jdbc.Driver
    jdbcUrl: jdbc:mysql://127.0.0.1:3306/shardingdb1?useSSL=false&serverTimezone=UTC&useUnicode=true&characterEncoding=UTF-8
    username: root
    password: newpwd

# 分片规则配置: https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/sharding/
rules:
  - !SHARDING # 分片规则配置
    # 绑定表：同分片键 join 时走同路由，减少广播,多个逗号分隔，要求分片规则一致
    bindingTables:
      - t_order,t_order_item

    tables: # 手工分片规则配置
      course: # 逻辑表名称
        actualDataNodes: ds_${0..1}.course_${1..2} # 实际数据节点
        databaseStrategy: # 分库策略
          standard: # 用于单分片键的标准分片场景
            shardingColumn: user_id # 分片列名称
            shardingAlgorithmName: course_db_inline # 分片算法名称
        tableStrategy: # 分表策略
          standard:
            shardingColumn: cid
            shardingAlgorithmName: course_inline
        keyGenerateStrategy: # 分布式序列策略
          column: cid # 自增列名称
          keyGeneratorName: snowflake # 分布式序列算法名称
      t_order_complex: # 逻辑表名称
        actualDataNodes: ds_${0..1}.t_order_complex_${0..1} # 实际数据节点
        databaseStrategy: # 分库策略
          standard: # 用于单分片键的标准分片场景
            shardingColumn: user_id # 分片列名称
            shardingAlgorithmName: t_order_db_inline # 分片算法名称
        tableStrategy: # 分表策略
          complex: # 用于多分片键的复杂分片场景
            shardingColumns: user_id,order_id
            shardingAlgorithmName: t_order-complex-algorithm
        keyGenerateStrategy: # 分布式序列策略
          column: order_id # 自增列名称
          keyGeneratorName: snowflake # 分布式序列算法名称
      t_order_item_complex: # 逻辑表名称
        actualDataNodes: ds_${0..1}.t_order_item_complex_${0..1} # 实际数据节点
        databaseStrategy: # 分库策略
          standard: # 用于单分片键的标准分片场景
            shardingColumn: user_id # 分片列名称
            shardingAlgorithmName: t_order_db_inline # 分片算法名称
        tableStrategy: # 分表策略
          complex: # 用于多分片键的复杂分片场景
            shardingColumns: user_id,order_id  # 分片列名称,多个逗号分隔
#             shardingAlgorithmName: t_order_item-class-based-algorithm   # 基于自定义类的分片算法
            shardingAlgorithmName: t_order_item-class-based-algorithm_spi # 基于 SPI 的分片算法，效果同上，建议生产环境使用 SPI
        keyGenerateStrategy: # 分布式序列策略
          column: item_id # 自增列名称
          keyGeneratorName: snowflake # 分布式序列算法名称

      t_user:
        actualDataNodes: ds_${0..1}.t_user_${0..1} # 实际数据节点
        databaseStrategy: # 分库策略
          standard: # 用于单分片键的标准分片场景
            shardingColumn: id # 分片列名称
            shardingAlgorithmName: t_user_db_inline # 分片算法名称
        tableStrategy: # 分表策略
          standard:
            shardingColumn: id  # 分片列名称
            shardingAlgorithmName: t_user_inline # 分片算法名称
        keyGenerateStrategy: # 分布式序列策略
          column: id # 自增列名称，字符串类型
#           keyGeneratorName: uuid # 分布式序列算法名称
          keyGeneratorName: custom_snowflake_string # 分布式序列算法名称


#       t_address:      # 普通表（不分库分表，绑定到 ds_0）,没有默认的数据源配置，所以每个都要显示声明
#         actualDataNodes: ds_0.t_address # 实际数据节点

    autoTables: # 自动分片规则配置
      t_order: # 逻辑表名称
        actualDataSources: ds_${0..1} # 数据源名称
        shardingStrategy: # 切分策略
          standard: # 用于单分片键的标准分片场景
            shardingColumn: user_id # 分片列名称
            shardingAlgorithmName: mod_2 # 自动分片算法名称
        keyGenerateStrategy: # 分布式序列策略
          column: order_id # 自增列名称
          keyGeneratorName: snowflake # 分布式序列算法名称
      t_order_item: # 逻辑表名称
        actualDataSources: ds_${0..1} # 数据源名称
        shardingStrategy: # 切分策略
          standard: # 用于单分片键的标准分片场景
            shardingColumn: user_id # 分片列名称
            shardingAlgorithmName: mod_2 # 自动分片算法名称
        keyGenerateStrategy: # 分布式序列策略
          column: item_id # 自增列名称
          keyGeneratorName: snowflake # 分布式序列算法名称

    shardingAlgorithms: # 分片算法 https://shardingsphere.apache.org/document/current/cn/dev-manual/sharding/
      course_inline: # 定义名称，在上面引用
        type: INLINE # 基于行表达式的分片算法，这里使用 MOD 会报错
        props: # 属性
          algorithm-expression: course_${cid % 2 + 1} # 表达式，这是因为表名称为 course_1, course_2
          allow-range-query-with-inline-sharding: true # 允许范围查询
      course_db_inline:
        type: INLINE
        props:
          algorithm-expression: ds_${user_id % 2} # 表示 ds_0, ds_1
      mod_2:
        type: MOD # 基于 MOD 的分片算法
        props:
          sharding-count: 2 # 分片数量，即 对 2 进行取余
      t_order_db_inline:
        type: INLINE
        props:
          algorithm-expression: ds_${user_id % 2}
      t_order-complex-algorithm:
        type: COMPLEX_INLINE # 基于行表达式的复合分片算法
        props:
          algorithm-expression: t_order_complex_${(user_id + order_id + 1) % 2}
      t_order_item-class-based-algorithm:
        type: CLASS_BASED # 基于自定义类的分片算法
        props:
          strategy: COMPLEX # 指定策略 STANDARD|COMPLEX|HINT ，告诉 ShardingSphere 分片算法类实现了什么策略
          algorithmClassName: com.hanqf.demo.support.algorithm.OrderItemComplexAlgorithm # 指定算法类
      t_order_item-class-based-algorithm_spi: # SPI
        type: T_ORDER_ITEM_COMPLEX # 基于自定义类的分片算法
      t_user_db_inline:
        type: INLINE
        props:
          algorithm-expression: ds_${Math.abs(id.hashCode()%2)}
      t_user_inline:
        type: INLINE
        props:
          algorithm-expression: t_user_${Math.abs(id.hashCode()%4).intdiv(2)}

    keyGenerators: # 分布式主键生成器: https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/builtin-algorithm/keygen/
      snowflake: # 定义名称，在上面引用
        type: SNOWFLAKE # 使用雪花算法，Long
      uuid:    # 定义名称
        type: UUID # 字符串主键，String
      custom_snowflake_string:
        type: CUSTOM_SNOWFLAKE_STRING
        props:
          workerId: 2
          datacenterId: 2

  - !BROADCAST  # 广播表配置，即所有的库中都包含指定的表，写入数据时同时写入多个库，查询时随机读一个
    tables:
      - dict    # 广播表名称，⼴播表不能配置分表逻辑，只往多个库的同⼀个表中插⼊数据。

  - !ENCRYPT    # 数据加密配置
    tables:
      t_user:  # 加密表名称
        columns:
          password: # 加密列名称
            cipher:
              name: password # 密文列名称
              encryptorName: aes_encryptor # 密文列加密算法名称
    # 加密算法配置: https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/builtin-algorithm/encrypt/
    encryptors:
      aes_encryptor: # 加解密算法名称
        type: AES # 加解密算法类型
        props: # 加解密算法属性配置
          aes-key-value: 123456abc     # AES 使用的 KEY
          digest-algorithm-name: SHA-1 # AES KEY 的摘要算法
      md5_encryptor:
        type: MD5
        props:
          salt: 123456  # 盐值（可选）

  - !MASK  # 数据脱敏配置
    tables:
      t_user:  # 脱敏表名称
        columns:  # 脱敏列配置
          password: # 脱敏列名称
            maskAlgorithm: md5_mask # 脱敏算法名称
          email:
            maskAlgorithm: mask_before_special_chars_mask
          telephone:
            maskAlgorithm: keep_first_n_last_m_mask
          name:
            maskAlgorithm: my_mask

    maskAlgorithms: # 脱敏算法配置
      md5_mask: # 自定义脱敏算法名称
        type: MD5  # 脱敏算法类型，md5加密后展示
      mask_before_special_chars_mask:
        type: MASK_BEFORE_SPECIAL_CHARS # 在特殊字符（比如邮箱里的 @）前面做脱敏，示例：myemail@example.com → *******@example.com
        props:
          special-chars: '@'  # 遇到 @ 之前的部分做脱敏
          replace-char: '*'   # 脱敏字符用 * 代替
      keep_first_n_last_m_mask:
        type: KEEP_FIRST_N_LAST_M # 保留前 n 位和后 m 位，其余用替换字符填充，示例：13812345678 → 138****5678
        props:
          first-n: 3     # 保留前 3 位
          last-m: 4      # 保留后 4 位
          replace-char: '*' # 脱敏字符用 * 代替
      my_mask:
        type: MY_CUSTOM_MASK  # 自定义脱敏算法名称
        props:
          replace-char: "#"


  - !SINGLE # 单表规则配置，单表规则优先级高于分库分表规则
    tables:
      # MySQL 风格
      - ds_0.t_address # 加载指定单表
#       - ds_1.* # 加载指定数据源中的全部单表
#       - "*.*" # 加载全部单表

# 属性配置：https://shardingsphere.apache.org/document/current/cn/user-manual/common-config/props/
props:
  sql-show: true # 控制台打印改写后的 SQL，便于排错，默认为 false
  check-table-metadata-enabled: false # 在程序启动和更新时，是否检查分片元数据的结构一致性，默认为 false
